// This file was generated by gir (e48471c+) from gir-files (???)
// DO NOT EDIT

use ffi;
use glib_ffi;
use glib::error::ErrorDomain;
use glib::translate::*;

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CursorBlinkMode {
    System,
    On,
    Off,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CursorBlinkMode {
    type GlibType = ffi::VteCursorBlinkMode;

    fn to_glib(&self) -> ffi::VteCursorBlinkMode {
        match *self {
            CursorBlinkMode::System => ffi::VTE_CURSOR_BLINK_SYSTEM,
            CursorBlinkMode::On => ffi::VTE_CURSOR_BLINK_ON,
            CursorBlinkMode::Off => ffi::VTE_CURSOR_BLINK_OFF,
            CursorBlinkMode::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorBlinkMode> for CursorBlinkMode {
    fn from_glib(value: ffi::VteCursorBlinkMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_CURSOR_BLINK_SYSTEM => CursorBlinkMode::System,
            ffi::VTE_CURSOR_BLINK_ON => CursorBlinkMode::On,
            ffi::VTE_CURSOR_BLINK_OFF => CursorBlinkMode::Off,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum CursorShape {
    Block,
    Ibeam,
    Underline,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for CursorShape {
    type GlibType = ffi::VteCursorShape;

    fn to_glib(&self) -> ffi::VteCursorShape {
        match *self {
            CursorShape::Block => ffi::VTE_CURSOR_SHAPE_BLOCK,
            CursorShape::Ibeam => ffi::VTE_CURSOR_SHAPE_IBEAM,
            CursorShape::Underline => ffi::VTE_CURSOR_SHAPE_UNDERLINE,
            CursorShape::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorShape> for CursorShape {
    fn from_glib(value: ffi::VteCursorShape) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_CURSOR_SHAPE_BLOCK => CursorShape::Block,
            ffi::VTE_CURSOR_SHAPE_IBEAM => CursorShape::Ibeam,
            ffi::VTE_CURSOR_SHAPE_UNDERLINE => CursorShape::Underline,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum EraseBinding {
    Auto,
    AsciiBackspace,
    AsciiDelete,
    DeleteSequence,
    Tty,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for EraseBinding {
    type GlibType = ffi::VteEraseBinding;

    fn to_glib(&self) -> ffi::VteEraseBinding {
        match *self {
            EraseBinding::Auto => ffi::VTE_ERASE_AUTO,
            EraseBinding::AsciiBackspace => ffi::VTE_ERASE_ASCII_BACKSPACE,
            EraseBinding::AsciiDelete => ffi::VTE_ERASE_ASCII_DELETE,
            EraseBinding::DeleteSequence => ffi::VTE_ERASE_DELETE_SEQUENCE,
            EraseBinding::Tty => ffi::VTE_ERASE_TTY,
            EraseBinding::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteEraseBinding> for EraseBinding {
    fn from_glib(value: ffi::VteEraseBinding) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_ERASE_AUTO => EraseBinding::Auto,
            ffi::VTE_ERASE_ASCII_BACKSPACE => EraseBinding::AsciiBackspace,
            ffi::VTE_ERASE_ASCII_DELETE => EraseBinding::AsciiDelete,
            ffi::VTE_ERASE_DELETE_SEQUENCE => EraseBinding::DeleteSequence,
            ffi::VTE_ERASE_TTY => EraseBinding::Tty,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum PtyError {
    PtyHelperFailed,
    Pty98Failed,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for PtyError {
    type GlibType = ffi::VtePtyError;

    fn to_glib(&self) -> ffi::VtePtyError {
        match *self {
            PtyError::PtyHelperFailed => ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED,
            PtyError::Pty98Failed => ffi::VTE_PTY_ERROR_PTY98_FAILED,
            PtyError::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VtePtyError> for PtyError {
    fn from_glib(value: ffi::VtePtyError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED => PtyError::PtyHelperFailed,
            ffi::VTE_PTY_ERROR_PTY98_FAILED => PtyError::Pty98Failed,
        }
    }
}

impl ErrorDomain for PtyError {
    fn domain() -> glib_ffi::GQuark {
        skip_assert_initialized!();
        unsafe { ffi::vte_pty_error_quark() }
    }

    fn code(self) -> i32 {
        self.to_glib() as i32
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            x if x == ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED as i32 => Some(PtyError::PtyHelperFailed),
            x if x == ffi::VTE_PTY_ERROR_PTY98_FAILED as i32 => Some(PtyError::Pty98Failed),
            _ => Some(PtyError::__Nonexhaustive(())),
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub enum WriteFlags {
    Default,
    #[doc(hidden)]
    __Nonexhaustive(()),
}

#[doc(hidden)]
impl ToGlib for WriteFlags {
    type GlibType = ffi::VteWriteFlags;

    fn to_glib(&self) -> ffi::VteWriteFlags {
        match *self {
            WriteFlags::Default => ffi::VTE_WRITE_DEFAULT,
            WriteFlags::__Nonexhaustive(_) => panic!(),
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteWriteFlags> for WriteFlags {
    fn from_glib(value: ffi::VteWriteFlags) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_WRITE_DEFAULT => WriteFlags::Default,
            _ => WriteFlags::__Nonexhaustive(()),
        }
    }
}

